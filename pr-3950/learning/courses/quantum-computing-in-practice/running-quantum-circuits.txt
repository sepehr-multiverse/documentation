3:I[55092,[],""]
5:I[82023,[],""]
4:["slug","courses/quantum-computing-in-practice/running-quantum-circuits","c"]
0:["cfnSiIQ6N8P04EC_-s8Ba",[[["",{"children":["(content)",{"children":["learning",{"children":[["slug","courses/quantum-computing-in-practice/running-quantum-circuits","c"],{"children":["__PAGE__?{\"slug\":[\"courses\",\"quantum-computing-in-practice\",\"running-quantum-circuits\"]}",{}]}]}]}]},"$undefined","$undefined",true],["",{"children":["(content)",{"children":["learning",{"children":[["slug","courses/quantum-computing-in-practice/running-quantum-circuits","c"],{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(content)","children","learning","children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(content)","children","learning","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[null,"$L6"],null],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/documentation/pr-3950/_next/static/css/92e398f0eab78019.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/documentation/pr-3950/_next/static/css/edabfc86b5da686e.css","precedence":"next","crossOrigin":"$undefined"}]],"$L7"],null],null],["$L8",null]]]]
9:I[78117,["705","static/chunks/8bb4d8db-3b2a540370c4e1fc.js","340","static/chunks/340-2fab9b577ad44018.js","966","static/chunks/966-02a3dbf834f8f86f.js","757","static/chunks/757-dc58b827d88c217f.js","677","static/chunks/677-70389ad2c73dd150.js","1","static/chunks/1-1f0b15228186ffa1.js","185","static/chunks/app/layout-39dd4ebf8c99e46e.js"],"LinguiClientProvider"]
a:I[47440,["705","static/chunks/8bb4d8db-3b2a540370c4e1fc.js","340","static/chunks/340-2fab9b577ad44018.js","966","static/chunks/966-02a3dbf834f8f86f.js","757","static/chunks/757-dc58b827d88c217f.js","677","static/chunks/677-70389ad2c73dd150.js","1","static/chunks/1-1f0b15228186ffa1.js","185","static/chunks/app/layout-39dd4ebf8c99e46e.js"],"CarbonFeatureFlagsProvider"]
b:I[35532,["705","static/chunks/8bb4d8db-3b2a540370c4e1fc.js","340","static/chunks/340-2fab9b577ad44018.js","966","static/chunks/966-02a3dbf834f8f86f.js","757","static/chunks/757-dc58b827d88c217f.js","677","static/chunks/677-70389ad2c73dd150.js","1","static/chunks/1-1f0b15228186ffa1.js","185","static/chunks/app/layout-39dd4ebf8c99e46e.js"],"ThemeProvider"]
c:I[18025,["705","static/chunks/8bb4d8db-3b2a540370c4e1fc.js","340","static/chunks/340-2fab9b577ad44018.js","966","static/chunks/966-02a3dbf834f8f86f.js","757","static/chunks/757-dc58b827d88c217f.js","677","static/chunks/677-70389ad2c73dd150.js","1","static/chunks/1-1f0b15228186ffa1.js","185","static/chunks/app/layout-39dd4ebf8c99e46e.js"],"TooltipProvider"]
d:I[86349,["705","static/chunks/8bb4d8db-3b2a540370c4e1fc.js","340","static/chunks/340-2fab9b577ad44018.js","966","static/chunks/966-02a3dbf834f8f86f.js","757","static/chunks/757-dc58b827d88c217f.js","677","static/chunks/677-70389ad2c73dd150.js","1","static/chunks/1-1f0b15228186ffa1.js","185","static/chunks/app/layout-39dd4ebf8c99e46e.js"],"ReactQueryProvider"]
e:I[7356,["705","static/chunks/8bb4d8db-3b2a540370c4e1fc.js","340","static/chunks/340-2fab9b577ad44018.js","966","static/chunks/966-02a3dbf834f8f86f.js","757","static/chunks/757-dc58b827d88c217f.js","677","static/chunks/677-70389ad2c73dd150.js","1","static/chunks/1-1f0b15228186ffa1.js","185","static/chunks/app/layout-39dd4ebf8c99e46e.js"],"Header"]
f:I[73027,["294","static/chunks/294-b64726fa1ab28e4e.js","601","static/chunks/app/error-27e7524bed43ba94.js"],"default"]
10:I[1795,["294","static/chunks/294-b64726fa1ab28e4e.js","160","static/chunks/app/not-found-7f20149522debcee.js"],"Error"]
11:I[82428,["705","static/chunks/8bb4d8db-3b2a540370c4e1fc.js","340","static/chunks/340-2fab9b577ad44018.js","966","static/chunks/966-02a3dbf834f8f86f.js","757","static/chunks/757-dc58b827d88c217f.js","677","static/chunks/677-70389ad2c73dd150.js","1","static/chunks/1-1f0b15228186ffa1.js","185","static/chunks/app/layout-39dd4ebf8c99e46e.js"],"AppFooter"]
12:I[77406,["705","static/chunks/8bb4d8db-3b2a540370c4e1fc.js","340","static/chunks/340-2fab9b577ad44018.js","966","static/chunks/966-02a3dbf834f8f86f.js","294","static/chunks/294-b64726fa1ab28e4e.js","544","static/chunks/544-69ed1fba22f464f4.js","757","static/chunks/757-dc58b827d88c217f.js","959","static/chunks/959-5bea59adf6f410c8.js","540","static/chunks/540-4b451e8a73aa2efe.js","222","static/chunks/app/(content)/learning/%5B...slug%5D/page-4bcd3bfe442a02e2.js"],"MdTabsGroupContextProvider"]
13:I[51165,["705","static/chunks/8bb4d8db-3b2a540370c4e1fc.js","340","static/chunks/340-2fab9b577ad44018.js","966","static/chunks/966-02a3dbf834f8f86f.js","544","static/chunks/544-69ed1fba22f464f4.js","677","static/chunks/677-70389ad2c73dd150.js","141","static/chunks/141-0ebcb3e31b8604b4.js","959","static/chunks/959-5bea59adf6f410c8.js","948","static/chunks/app/(content)/layout-651a0bdea668ef02.js"],"DocLeftNav"]
7:["$","html",null,{"lang":"en","suppressHydrationWarning":true,"className":"__variable_c62a79 __variable_97b4f9 font-sans","children":["$","body",null,{"children":["$","$L9",null,{"initialLocale":"en","initialMessages":{"+1f/wc":["The platform to execute, manage, and optimize quantum computing programs in real time"],"+oNljP":["Preview tools"],"+skAxO":["Responses"],"+yonAn":["View all tutorials"],"+zy2Nq":["Type"],"/1dlmO":["Qiskit SDK circuit library"],"/dqduX":["Next page"],"/x5yzj":["Quantum Chemistry with VQE"],"02j3fQ":["This page is from the dev version of ",["packageTitle"],"."],"0E73t0":["Superposition"],"0NSDB5":["Course 1"],"0WQuU3":["Course 3"],"1LLF3Z":["Thank you!"],"1UzENP":["No"],"1eQi7/":["Error code registry"],"1hrDiD":["Service alert"],"1yrcHM":["Focused topics"],"2DNE7C":["Course"],"2YvXbl":["This asset has been removed."],"2nOEbt":["Quantum information and computation III"],"2vOdnM":["Access management"],"3OTEvr":["Latest updates in docs"],"3epoJl":["Download notebook"],"3vCJre":["Qiskit YouTube"],"47HDRH":["Fundamentals of Quantum Algorithms"],"4Re3bo":["General formulation of quantum information"],"4Y5H+g":["Terms"],"4YOKG1":["Save and retrieve jobs"],"4vEn6W":["Quantum Machine Learning"],"5HmxD5":["Learn how quantum algorithms beat classical algorithms for problems including integer factoring and search."],"5JRvWu":["Make quantum measurements that emulate early discoveries in quantum mechanics."],"5K7Pcx":["Start with the fundamentals"],"5MKmJH":["Learn potential use cases and best practices for experimenting with quantum processors having 100+ qubits."],"5UrwpA":["<0>Help us improve Qiskit and IBM Quantum Platform!</0>Share your thoughts in our<1>annual feedback survey <2/></1>"],"5xHYno":["Practical introduction to quantum-safe cryptography"],"67KGxO":["Return to course"],"695okU":["Searching latest API versions."],"6H/Gr3":["Solution"],"6KaTm+":["Compute resources"],"6Kz0Yn":["Quantum teleportation"],"6Rj3Qj":["Github. Opens in new tab"],"6go+cK":["Explore utility-grade examples that leverage IBM Quantum and Qiskit technologies"],"6xXQZD":["Optimize for target hardware"],"73LUaD":["Take the exam"],"7Gm6xN":["Searching guides and additional resources."],"7WTcIZ":["Higher-order binary optimization with Q-CTRL's Optimization Solver"],"7u5sil":["Computer science"],"84S0z/":["Fundamentals of quantum algorithms"],"89ulog":["Qiskit ecosystem"],"8F1i42":["Page not found"],"8JYmfU":["This page has been removed in Qiskit version v2.0. Refer to the <0>migration guide</0> for more information."],"8SZw5y":["General Formulation of Quantum Information"],"8YVYOs":["Browse lectures, tips and tricks, tutorials, community updates, and more"],"8oLm3m":["Test whether hidden variables can explain quantum correlations."],"96L1tJ":["Multiple quantum approaches to matrix diagonalization are explored, including VQE, QKD, SKD, and variations of these."],"9AYfyY":["Quantum Business Foundations"],"9ZEsfg":["Bell’s inequality"],"A+UIII":["AI-enhanced transpiler passes"],"AeXO77":["Account"],"AnNF5e":["Accessibility"],"AwUsnG":["Instances"],"AxPAXW":["No results found"],"B4ESok":["API reference"],"BGh5Ab":["Use statistics to detect eavesdropping in the transfer of quantum information."],"BN6GyS":["Show past service alerts"],"BmfykU":["Guides"],"Bn5Biy":["Qiskit SDK API"],"CgZqvu":["Quantum Diagonalization Algorithms"],"D0wPqH":["New to the code assistant? See <0>Qiskit Code Assistant</0> for installation and usage. Note this is an experimental feature and only available to IBM Quantum Premium Plan users."],"D44kpy":["Stay up to date"],"DE/+E6":["New lesson"],"Dsd509":["Learn the risks quantum computing poses to cryptography and learn what approaches are quantum-safe."],"DvXHcx":["An introduction to VQE that covers basic building blocks and applications."],"Dzr23X":["Announcements"],"EDtmbJ":["No announcements. <0>Remove filters</0>."],"EeryVz":["Example Response"],"FWouRt":["Start the next lesson"],"FdPwB3":["Qiskit SDK's quantum_info module"],"FhPO2F":["A collection of learning assets from a 14-lesson course on utility-scale quantum computing."],"GYs0Ee":["Go to the stable version."],"GtIb5u":["Path Parameters"],"HLT8RS":["Use quantum computers to explore quantum phenomena like superposition and uncertainty."],"HbpnSq":["Hide past service alerts"],"HfhpWh":["Course 4"],"HmI5oK":["Example"],"INdXcS":["Explore more courses"],"IZsImN":["Quantum computing in practice"],"IzYcUI":["Start this course"],"J9TK/3":["Quantum Computing in Practice"],"JAC4Nh":["Quantum chemistry with VQE"],"Jrm1VG":["Quantum learning"],"K/A6Nd":["Discover the origins of uncertainty and probe well-known uncertainty relations."],"KqqLXk":["Searching ",["pkgTitle"]," ",["pkgVersion"]," and latest versions of other APIs."],"L1dpC6":["Explore utility-grade algorithms and applications with Qiskit Runtime"],"L8riJs":["Course series"],"LB7eBr":["Tutorials"],"LR64NR":["Designed to help incorporate quantum computing into traditional STEM classrooms, each module includes background, Qiskit code, practice questions, and an optional video component."],"LSbzqO":["Quantum business foundations"],"LmzBB/":["Main menu"],"MCJuvv":["Quantum information and computation I"],"MHWXtt":["<0>This page is from a dev version of ",["packageTitle"],".</0> This is a new interface that does not exist in the <1>stable version</1>."],"MPDZAH":["Continue your learning journey by diving into more focused topics related to quantum computing."],"MhI0W3":["Product update"],"Mo12j2":["Explore quantum approaches to matrix diagonalization, including VQE, QKD, SKD and variations of these."],"MxNCl2":["Learn how quantum information can be teleported, and move information on real quantum computers."],"N/Ev+9":["Courses to learn about quantum information and how quantum computing works, from the basics onward."],"N40H+G":["All"],"N6yRkj":["Explore the business applications of quantum computing and what it takes build a successful quantum initiative."],"NJ+DKw":["Introduction to execution modes"],"NOhc/J":["Specify Qiskit Runtime options"],"NV7qSY":["Variational algorithm design"],"NWy9QS":["Practical Introduction to Quantum Safe Cryptography"],"NXs1Dz":["Transpilation services in the cloud, including AI-enhanced transpiler passes"],"Nu4oKW":["Description"],"OqM4M7":["Verifiable sampling algorithms"],"Ou6W1b":["Code samples"],"Ov+DcD":["Browse videos"],"Ox/BJT":["Follow for live updates"],"PThbrz":["This documentation page no longer exists because it belongs to an archived version of our API reference."],"PZ6cWf":["Learn how quantum computations can be protected against noise through quantum error correcting codes and fault tolerance."],"Q+B4Hp":["Quantum key distribution"],"QI/UIM":["Quantum information and computation IV"],"QMW+f1":["Page no longer exists."],"RUjrPj":["HTTP Response Status Codes"],"S40yny":["Visit the <0>Hello world</0> tutorial to get started using Qiskit. For more details about error mitigation, consult the <1>Error mitigation and suppression techniques</1> guide and the <2>Combine error mitigation options with the Estimator primitive</2> tutorial."],"SOvBw9":["Was this page helpful?"],"SXPJiS":["Quantum diagonalization algorithms"],"T3FM0r":["Account settings"],"TK8eC3":["Error code"],"TM2/t5":["Qiskit in classrooms"],"TMLAx2":["Required"],"TO0HiH":["Learn quantum computing"],"TYZSmP":["Learn to leverage the power of quantum computing in machine learning methods."],"TgxFZg":["Introduction to primitives"],"TlEEts":["Default value"],"Tn5VWz":["Composer"],"TvY/XA":["Documentation"],"UDApdN":["The Deutsch-Jozsa algorithm"],"Upd5px":["Execute on target hardware"],"VM+wEW":["Workloads"],"VQ5ghi":["Go to the latest version"],"W3eaWW":["No active service alerts"],"WTWCB7":["Utility-scale quantum computing"],"WunjTJ":["View all courses"],"X4m/Wn":["<0>This page is from an old version of ",["packageTitle"]," and does not exist in the latest version.</0> We recommend you migrate to the <1>latest version</1>. See the <2>release notes</2> for more information."],"XS556R":["Report a bug or request content on <0>GitHub</0>."],"XYLcNv":["Support"],"XdArAS":["Modules"],"XhXmzW":["On this page"],"XojUBE":["Explore composer"],"YFY/YT":["Qiskit Transpiler Service is only available for IBM Quantum Premium Plan members."],"ZKucmQ":["Quantum Information & Computation"],"ZS4UWo":["Kickstart your quantum learning journey with a selection of courses designed to help you learn the basics or explore more focused topics. If you’re an instructor, explore content specifically tailored to incorporating quantum in the classroom."],"ZWaENH":["Quantum computing for business"],"ZlwDi6":["Analytics"],"a3LDKx":["Security"],"aF4Asd":["Learn the risks that quantum computing poses to cryptography, and explore which approaches are quantum-safe."],"aHKcKc":["Previous page"],"aTrDGk":["Explore a suite of instructional modules designed to help incorporate quantum computing into traditional STEM courses."],"arUUsK":["Product updates"],"astDB+":["Blog"],"bcbxDd":["Possible values"],"chL5IG":["Community"],"d/62dq":["Service alerts"],"daoY+a":["Translation information"],"djo0V+":["Quantum machine learning"],"e8aI3q":["This page is no longer available"],"e9mrIn":["Build circuits with Composer"],"eD4Gzb":["Map the problem to quantum circuits"],"eNvtWL":["This page is from an old version of ",["packageTitle"]],"eODNrw":["Additional resources"],"eaOxP/":["Transpile with pass managers"],"fE8KtV":["Teach quantum in your classroom"],"fJZIaf":["Dive deeper into quantum information, including density matrices, channels, and general measurements."],"fcWrnU":["Sign out"],"fijejj":["Migration guides"],"gLvz8M":["Cookie preferences"],"gP9mT2":["Track system outages and stay up to date with the latest news, announcements, and product updates"],"gXAud4":["Start the module"],"gukqfD":["See all"],"i0qMbr":["Home"],"iGaika":["Write a custom transpiler pass"],"isRobC":["New"],"jjkOMa":["Foundations of Quantum Error Correction"],"kqypmf":["Explore workflows toward utility"],"l2Op2p":["Query Parameters"],"l75CjT":["Yes"],"lDaNgF":["Basics of Quantum Information"],"lIgngF":["The course Building Successful Quantum Initiatives is no longer available as of 1 July 2025. Visit the <0>IBM Quantum Learning</0> home page to see the latest content. For information on business applications of quantum computing, see the course <1>Quantum business foundations.</1>"],"ldqyy3":["Response Schema"],"liU281":["Python client"],"lsY6FS":["Please try a different search query or <0>browse all documentation</0>."],"lxry+h":["Operator backpropagation (OBP) for estimation of expectation values"],"mDi3u5":["Updated learning pathways will be available soon. If you have urgent concerns in the interim, please email <0>christopher.porter1@ibm.com</0>"],"mNa8bN":["Builds foundations of quantum computing, technology, and business applications."],"mgntvM":["Name, Type"],"mxpHnn":["Visualize results"],"mzQCf5":["Guidance on how to use our key APIs"],"nIuT1m":["Run one of the earliest quantum algorithms, and compare many function outputs with a single evaluation."],"nOB789":["Post-process results"],"nwtY4N":["Something went wrong"],"oDxWPg":["Run some famous quantum algorithms, including Deutsch-Jozsa and QKD."],"oHHKmt":["All IBM Quantum® Learning assets have been moved to the new <0>Learning</0> page."],"orPPLo":["Foundations of quantum error correction"],"pLJXWn":["Courses"],"pWmfQV":["Foundations"],"pcpUfi":["Open-source toolkit for useful quantum computing"],"pj7mRB":["Observable estimation"],"qIHdNi":["Past service alerts"],"qx6vw/":["Whether you are ready to code your first circuit or execute a large research workload, you can find documentation for using Qiskit and IBM Quantum hardware at the following links."],"rLDuk7":["A framework for breaking down domain-specific problems and software capabilities in stages"],"rM1oZt":["Explore a suite of instructional materials designed to incorporate quantum computing into traditional STEM courses."],"rjGI/Q":["Privacy"],"s1YIi6":["Start exploring applications"],"s5nQe3":["Key techniques and applications"],"sH1sbz":["Module topic"],"syfmQd":["An introduction to VQE covering basic building blocks and applications."],"tBRnym":["Variational Algorithm Design"],"tEislA":["Start learning and applying quantum computing with Qiskit through our library of 10+ courses from leading experts."],"tWFL2S":["View archived documentation in GitHub"],"tglLAQ":["Construct circuits"],"thGVbW":["Stern-Gerlach"],"tp9sD5":["Explore how quantum systems can be in a superposition of two states at once."],"ttmdOj":["Error loading results"],"uJ+Ve2":["Region"],"uoD3gD":["Development workflow"],"vERlcd":["Profile"],"vGflkA":["Learn about quantum information, from states and measurements to quantum circuits and entanglement."],"vKMFLs":["Course 2"],"vZERUv":["Foundations of quantum computing"],"vgerp7":["Start the course"],"vqAmQC":["Module"],"vsn4xY":["Blog articles"],"wK4zlo":["Quantum mechanics"],"wVX8k+":["Translations of IBM Quantum documentation are a work in progress, and more translated sections are coming soon. If you have feedback on the translated text, <0>open an issue</0> in our GitHub repository."],"wnDIXm":["Build and simulate circuits with a drag and drop interface"],"wqxglO":["Learning"],"xANKBj":["Functions"],"xAq4YZ":["Sample-based quantum diagonalization of a chemistry Hamiltonian"],"xDAtGP":["Message"],"xGEVAy":["View latest version"],"xKbBfU":["Launch exam"],"xu808o":["An overview of variational algorithms: hybrid classical quantum algorithms."],"ySayPI":["Uncertainty"],"ydKahT":["Open-source resources"],"ylJ6s5":["Status code"],"ymChLG":["Quantum information and computation II"],"ynQtsK":["All documentation"],"zDfH4h":["IBM Quantum blog"],"zELJdm":["View all modules"],"zMjN8w":["REST API"],"zj7wqQ":["Body Parameters"],"zm0jtV":["with John Watrous"],"zsGE/L":["with Olivia Lanes"],"zuTZPY":["Get started with Hello World"],"zxzY7y":["Basics of quantum information"],"+O3PfQ":["Select account"],"5lWFkC":["Sign in"],"A1taO8":["Search"],"Daibnq":["Search filter"],"FEr96N":["Theme"],"GtpQwI":["Dark theme"],"Ms9Ey3":["Opens in new tab"],"N2S1rs":["Empty"],"PjNgzy":["Region switcher"],"QcC4JO":["Open search dialog"],"Qvw5Gm":["System preference"],"V8yTm6":["Clear search"],"aj9K+R":["Account switcher"],"dPpHZL":["Light theme"],"dXuQTR":["Select region"],"e0jJAK":["Side navigation"],"udPwLB":["Header"],"vcpc5o":["Close menu"],"vuosjb":["User menu"],"xCJdfg":["Clear"]},"children":["$","$La",null,{"children":["$","$Lb",null,{"children":["$","$Lc",null,{"children":["$","$Ld",null,{"children":[["$","$Le",null,{}],["$","div",null,{"className":"pt-[var(--app-header-height)]","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$f","errorStyles":[],"errorScripts":[],"template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","$L10",null,{"title":"Page not found","description":"Sorry, but the page you were looking for could not be found."}],"notFoundStyles":[]}]}],["$","$L11",null,{}]]}]}]}]}]}]}]}]
6:["$","$L12",null,{"children":["$","div",null,{"className":"flex relative","children":[["$","$L13",null,{"tocPaths":["/docs/guides","/docs/migration-guides","/docs/open-source","/docs/security","/docs/support","/docs/tutorials","/learning/courses/basics-of-quantum-information","/learning/courses/foundations-of-quantum-error-correction","/learning/courses/fundamentals-of-quantum-algorithms","/learning/courses/general-formulation-of-quantum-information","/learning/courses/quantum-business-foundations","/learning/courses/quantum-chem-with-vqe","/learning/courses/quantum-computing-in-practice","/learning/courses/quantum-diagonalization-algorithms","/learning/courses/quantum-machine-learning","/learning/courses/quantum-safe-cryptography","/learning/courses/utility-scale-quantum-computing","/learning/courses/variational-algorithm-design","/learning/modules/computer-science","/learning/modules/quantum-mechanics"],"endpointsPrefix":""}],["$","div",null,{"className":"flex-1","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(content)","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]}]]}]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Preview: Running quantum circuits"}],["$","meta","3",{"name":"description","content":"A high-level look at the basics of running a utility-scale quantum computation."}],["$","meta","4",{"name":"robots","content":"none"}],["$","meta","5",{"property":"og:title","content":"Running quantum circuits | IBM Quantum Documentation"}],["$","meta","6",{"property":"og:description","content":"A high-level look at the basics of running a utility-scale quantum computation."}],["$","meta","7",{"property":"og:site_name","content":"IBM Quantum Documentation"}],["$","meta","8",{"property":"og:type","content":"website"}],["$","meta","9",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","10",{"name":"twitter:creator","content":"@IBM"}],["$","meta","11",{"name":"twitter:title","content":"Running quantum circuits | IBM Quantum Documentation"}],["$","meta","12",{"name":"twitter:description","content":"A high-level look at the basics of running a utility-scale quantum computation."}],["$","link","13",{"rel":"icon","href":"/favicon.ico"}],["$","meta","14",{"name":"next-size-adjust"}]]
1:null
19:I[16340,["705","static/chunks/8bb4d8db-3b2a540370c4e1fc.js","340","static/chunks/340-2fab9b577ad44018.js","966","static/chunks/966-02a3dbf834f8f86f.js","294","static/chunks/294-b64726fa1ab28e4e.js","544","static/chunks/544-69ed1fba22f464f4.js","757","static/chunks/757-dc58b827d88c217f.js","959","static/chunks/959-5bea59adf6f410c8.js","540","static/chunks/540-4b451e8a73aa2efe.js","222","static/chunks/app/(content)/learning/%5B...slug%5D/page-4bcd3bfe442a02e2.js"],""]
1a:I[54795,["705","static/chunks/8bb4d8db-3b2a540370c4e1fc.js","340","static/chunks/340-2fab9b577ad44018.js","966","static/chunks/966-02a3dbf834f8f86f.js","294","static/chunks/294-b64726fa1ab28e4e.js","544","static/chunks/544-69ed1fba22f464f4.js","757","static/chunks/757-dc58b827d88c217f.js","959","static/chunks/959-5bea59adf6f410c8.js","540","static/chunks/540-4b451e8a73aa2efe.js","222","static/chunks/app/(content)/learning/%5B...slug%5D/page-4bcd3bfe442a02e2.js"],"Image"]
1b:I[18803,["705","static/chunks/8bb4d8db-3b2a540370c4e1fc.js","340","static/chunks/340-2fab9b577ad44018.js","966","static/chunks/966-02a3dbf834f8f86f.js","294","static/chunks/294-b64726fa1ab28e4e.js","544","static/chunks/544-69ed1fba22f464f4.js","757","static/chunks/757-dc58b827d88c217f.js","959","static/chunks/959-5bea59adf6f410c8.js","540","static/chunks/540-4b451e8a73aa2efe.js","222","static/chunks/app/(content)/learning/%5B...slug%5D/page-4bcd3bfe442a02e2.js"],"LearningPager"]
1c:I[36486,["705","static/chunks/8bb4d8db-3b2a540370c4e1fc.js","340","static/chunks/340-2fab9b577ad44018.js","966","static/chunks/966-02a3dbf834f8f86f.js","294","static/chunks/294-b64726fa1ab28e4e.js","544","static/chunks/544-69ed1fba22f464f4.js","757","static/chunks/757-dc58b827d88c217f.js","959","static/chunks/959-5bea59adf6f410c8.js","540","static/chunks/540-4b451e8a73aa2efe.js","222","static/chunks/app/(content)/learning/%5B...slug%5D/page-4bcd3bfe442a02e2.js"],"PageToc"]
16:{"d":"M29.25,6.76a6,6,0,0,0-8.5,0l1.42,1.42a4,4,0,1,1,5.67,5.67l-8,8a4,4,0,1,1-5.67-5.66l1.41-1.42-1.41-1.42-1.42,1.42a6,6,0,0,0,0,8.5A6,6,0,0,0,17,25a6,6,0,0,0,4.27-1.76l8-8A6,6,0,0,0,29.25,6.76Z"}
15:["$","path",null,"$16"]
18:{"d":"M4.19,24.82a4,4,0,0,1,0-5.67l8-8a4,4,0,0,1,5.67,0A3.94,3.94,0,0,1,19,14a4,4,0,0,1-1.17,2.85L15.71,19l1.42,1.42,2.12-2.12a6,6,0,0,0-8.51-8.51l-8,8a6,6,0,0,0,0,8.51A6,6,0,0,0,7,28a6.07,6.07,0,0,0,4.28-1.76L9.86,24.82A4,4,0,0,1,4.19,24.82Z"}
17:["$","path",null,"$18"]
2:["$","div",null,{"className":"grid grid-cols-[1fr,auto] relative","children":[["$","div",null,{"className":"min-h-app max-w-[var(--main-container-max-width)]","children":[["$","div",null,{"className":"pt-16 px-16 xlg:px-32 bg-layer z-10 sticky top-[var(--app-header-height)] flex flex-col gap-[12px]","children":["$","div",null,{"className":"rounded border border-yellow-30/30 dark:border-yellow-30 bg-yellow-10 dark:bg-cool-gray-100","children":["$","div",null,{"className":"flex items-start gap-8 px-16 py-[12px]","children":[["$","svg",null,{"focusable":"false","preserveAspectRatio":"xMidYMid meet","fill":"var(--cds-support-warning)","aria-hidden":true,"width":"16","height":"16","viewBox":"0 0 16 16","className":"flex-shrink-0 mt-[1px] [&_path[data-icon-path='inner-path']]:fill-[#000] [&_path[data-icon-path='inner-path']]:opacity-100","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M8,1C4.2,1,1,4.2,1,8s3.2,7,7,7s7-3.1,7-7S11.9,1,8,1z M7.5,4h1v5h-1C7.5,9,7.5,4,7.5,4z M8,12.2 c-0.4,0-0.8-0.4-0.8-0.8s0.3-0.8,0.8-0.8c0.4,0,0.8,0.4,0.8,0.8S8.4,12.2,8,12.2z"}],["$","path",null,{"d":"M7.5,4h1v5h-1C7.5,9,7.5,4,7.5,4z M8,12.2c-0.4,0-0.8-0.4-0.8-0.8s0.3-0.8,0.8-0.8 c0.4,0,0.8,0.4,0.8,0.8S8.4,12.2,8,12.2z","data-icon-path":"inner-path","opacity":"0"}],"$undefined"]}],["$","div",null,{"className":"text-body-01 text-text-primary","children":[["$","span",null,{"className":"text-heading-compact-01","children":"This is a preview build of IBM Quantum® documentation."}]," ","Refer to ",["$","a",null,{"href":"https://quantum.cloud.ibm.com/docs","className":"text-link-primary no-underline hover:underline inline","children":"quantum.cloud.ibm.com/docs"}]," for the official documentation."]}]]}]}]}],["$","main",null,{"id":"main-content","className":"mx-16 md:mx-96 lg:mx-[56px] xlg:mx-96 pb-96 pt-0 max-w-full md:max-w-[800px]","children":["$","div",null,{"className":"prose","children":[[["$","h1",null,{"id":"running-quantum-circuits","className":"group relative mx-0 scroll-pt-[var(--shell-top-bar-height)] [overflow-wrap:anywhere] text-heading-06 text-text-primary","children":["Running quantum circuits",["$","a",null,{"title":"Permalink to this headline","href":"#running-quantum-circuits","className":"text-link-primary no-underline hover:underline inline heading-permalink ml-[8px] top-0 opacity-0 group-hover:opacity-100 focus:opacity-100 transition-[opacity] duration-75 ease-[cubic-bezier(0.2,0,0.38,0.9)]","children":["$","svg",null,{"focusable":"false","preserveAspectRatio":"xMidYMid meet","fill":"currentColor","width":16,"height":16,"viewBox":"0 0 32 32","aria-hidden":true,"className":"inline","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M29.25,6.76a6,6,0,0,0-8.5,0l1.42,1.42a4,4,0,1,1,5.67,5.67l-8,8a4,4,0,1,1-5.67-5.66l1.41-1.42-1.41-1.42-1.42,1.42a6,6,0,0,0,0,8.5A6,6,0,0,0,17,25a6,6,0,0,0,4.27-1.76l8-8A6,6,0,0,0,29.25,6.76Z"}],["$","path",null,{"d":"M4.19,24.82a4,4,0,0,1,0-5.67l8-8a4,4,0,0,1,5.67,0A3.94,3.94,0,0,1,19,14a4,4,0,0,1-1.17,2.85L15.71,19l1.42,1.42,2.12-2.12a6,6,0,0,0-8.51-8.51l-8,8a6,6,0,0,0,0,8.51A6,6,0,0,0,7,28a6.07,6.07,0,0,0,4.28-1.76L9.86,24.82A4,4,0,0,1,4.19,24.82Z"}],"$undefined"]}]}]]}],"\n",["$","p",null,{"children":["Watch the video on quantum circuits and primitives from Olivia Lanes, or open the video in a separate window on ",["$","a",null,{"href":"https://youtube.com/watch?v=NTplT4WnNbk","className":"text-link-primary no-underline hover:underline inline","target":"_blank","rel":"noopener nofollow noreferrer","children":["YouTube.",["$","svg",null,{"focusable":"false","preserveAspectRatio":"xMidYMid meet","fill":"currentColor","aria-label":"(opens in a new tab)","width":16,"height":16,"viewBox":"0 0 32 32","role":"img","className":"inline ml-2","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M10 6L10 8 22.59 8 6 24.59 7.41 26 24 9.41 24 22 26 22 26 6 10 6z"}],"$undefined"]}]]}]],"className":"group paragraph-el text-text-primary mx-0"}],"\n","$L14","\n",[["$","hr",null,{"className":"mt-48 lg:mt-64 mb-16 md:mb-24 my-16 lg:my-24 border-t border-border-subtle box-content overflow-visible"}],["$","h2",null,{"id":"lesson-overview","className":"group relative mx-0 scroll-pt-[var(--shell-top-bar-height)] [overflow-wrap:anywhere] text-heading-04 text-text-primary","children":["Lesson overview",["$","a",null,{"title":"Permalink to this headline","href":"#lesson-overview","className":"text-link-primary no-underline hover:underline inline heading-permalink ml-[8px] top-0 opacity-0 group-hover:opacity-100 focus:opacity-100 transition-[opacity] duration-75 ease-[cubic-bezier(0.2,0,0.38,0.9)]","children":["$","svg",null,{"focusable":"false","preserveAspectRatio":"xMidYMid meet","fill":"currentColor","width":16,"height":16,"viewBox":"0 0 32 32","aria-hidden":true,"className":"inline","xmlns":"http://www.w3.org/2000/svg","children":["$15","$17","$undefined"]}]}]]}]],"\n",["$","p",null,{"children":"This lesson will be a high-level look at the basics of running a utility-scale quantum computation, from the quantum hardware used to principles to consider when designing a quantum circuit. Ideally, by the end of this lesson, you'll know:","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"What IBM® quantum computers actually are. You'll need to know the basics of the hardware features to optimally design your quantum circuits to run on it.","className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"What Qiskit is, what primitives are, and how we can use them to create and execute quantum circuits.","className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"The typical workflow we follow to run experiments at scale. This includes selecting the best primitives for your use-case, mapping a problem to a quantum circuit, and applying error mitigation and suppression, which enable us to squeeze as much power out of these machines as possible.","className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n"],"className":"list-outside ml-32 list-decimal tabular-nums"}],"\n",[["$","hr",null,{"className":"mt-48 lg:mt-64 mb-16 md:mb-24 my-16 lg:my-24 border-t border-border-subtle box-content overflow-visible"}],["$","h2",null,{"id":"hardware--ibm-quantum-processors","className":"group relative mx-0 scroll-pt-[var(--shell-top-bar-height)] [overflow-wrap:anywhere] text-heading-04 text-text-primary","children":["Hardware – IBM quantum processors",["$","a",null,{"title":"Permalink to this headline","href":"#hardware--ibm-quantum-processors","className":"text-link-primary no-underline hover:underline inline heading-permalink ml-[8px] top-0 opacity-0 group-hover:opacity-100 focus:opacity-100 transition-[opacity] duration-75 ease-[cubic-bezier(0.2,0,0.38,0.9)]","children":["$","svg",null,{"focusable":"false","preserveAspectRatio":"xMidYMid meet","fill":"currentColor","width":16,"height":16,"viewBox":"0 0 32 32","aria-hidden":true,"className":"inline","xmlns":"http://www.w3.org/2000/svg","children":["$15","$17","$undefined"]}]}]]}]],"\n",["$","p",null,{"children":"To understand how we can make optimal choices in designing large-scale quantum circuits, we need to know a little bit about the actual hardware that will run these circuits. So let's briefly discuss physical qubits and IBM quantum processors.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":["IBM quantum processors are built using superconducting transmon qubits, which are electrical circuits composed of a ",["$","em",null,{"children":"Josephson junction"}]," and a capacitor connected in parallel. The Josephson junction is a nonlinear inductor created from two overlapping layers of superconducting metal with an insulating barrier between them. At very low temperatures, the electrons in superconductors pair up to form what is known as a cooper pair. Cooper pairs can spontaneously tunnel through the insulating barrier from one side of the junction to the other. This tunneling behavior gives rise to the nonlinear properties which create our qubit."],"className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":["Microwave transmission lines are fabricated on the chip to deliver microwave signals to the qubits. When we apply highly calibrated microwave pulses — with specific frequency, amplitude, shape, and duration — to the lines, we can make the qubits do specific things. This forms the basis of our quantum gates. We fabricate the chip so that neighboring qubits are connected in a specific lattice structure called a heavy-hex lattice. This connectivity — the so-called ",["$","em",null,{"children":"topology"}]," — of our processors is an important factor to consider when designing a circuit, as we'll discuss later in the lesson."],"className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"The instructions for the microwave pulse go from your computer, through the cloud, and to room-temperature control electronics, which interpret those instructions and physically generate the pulses. After the room-temperature control boxes create the pulses, they travel through cables into a dilution refrigerator and eventually to the quantum chip. The signal goes into the resonators, through a wirebond, and then flows down the transmission line into our qubits.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":["IBM has dozens of quantum computers around the world, and we've recently upgraded our fleet to exclusively have processors larger than 100 qubits. Some of them are located in an IBM quantum data center in upstate New York and deployed over the cloud for everyone's use — and some of them are dedicated, on-premises systems that support partners in the IBM Quantum® Network. You can log into ",["$","a",null,{"href":"https://quantum.cloud.ibm.com","className":"text-link-primary no-underline hover:underline inline","children":"quantum.cloud.ibm.com"}]," to see which processors you have access to."],"className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"Each processor lists three performance metrics, which we discussed in the previous lesson, but as a reminder, they are: qubit count, EPLG, and CLOPS.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Qubit count."}]," This is self-explanatory: it's the number of total qubits available to use on a sole quantum processor. For a relatively large, utility-scale problem, you'll need to make sure you are using a processor with enough qubits to be able to tackle the problem. But the qubit count alone is not the only thing that matters."],"className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"EPLG,"}]," or “errors per layered gate.” This is a measure of the quality of the qubits and quantum gates. It measures the average error each gate introduces in a circuit that entangles neighboring qubits in a chain of 100 qubits. You want this to be as small as possible."],"className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"CLOPS,"}]," or “circuit layer operations per second.” This quantifies the speed of the processor. It measures how many layers of a certain benchmarking circuit called a quantum volume circuit a quantum processing unit (QPU) can execute per unit of time. The higher the number, the faster we can compute."],"className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n"],"className":"list-outside ml-16 px-16 list-disc"}],"\n",["$","p",null,{"children":"The importance of each of these metrics varies depending on the specific application, and in future lessons, we'll look at real examples to see how each of these factors can affect the outcome of a calculation.","className":"group paragraph-el text-text-primary mx-0"}],"\n",[["$","hr",null,{"className":"mt-48 lg:mt-64 mb-16 md:mb-24 my-16 lg:my-24 border-t border-border-subtle box-content overflow-visible"}],["$","h2",null,{"id":"software-qiskit-and-qiskit-runtime","className":"group relative mx-0 scroll-pt-[var(--shell-top-bar-height)] [overflow-wrap:anywhere] text-heading-04 text-text-primary","children":["Software: Qiskit and Qiskit Runtime",["$","a",null,{"title":"Permalink to this headline","href":"#software-qiskit-and-qiskit-runtime","className":"text-link-primary no-underline hover:underline inline heading-permalink ml-[8px] top-0 opacity-0 group-hover:opacity-100 focus:opacity-100 transition-[opacity] duration-75 ease-[cubic-bezier(0.2,0,0.38,0.9)]","children":["$","svg",null,{"focusable":"false","preserveAspectRatio":"xMidYMid meet","fill":"currentColor","width":16,"height":16,"viewBox":"0 0 32 32","aria-hidden":true,"className":"inline","xmlns":"http://www.w3.org/2000/svg","children":["$15","$17","$undefined"]}]}]]}]],"\n",["$","p",null,{"children":"To turn your quantum problem into instructions for a quantum computer, you'll use Qiskit, the open-source software development kit designed for work on quantum computers developed by IBM. There's also the Qiskit Ecosystem — a collection of software tutorials and functions that build or extend upon the core functionalities of Qiskit — and Qiskit Runtime — a quantum computing service and programming model that allows users to design and optimize their quantum workloads and execute them efficiently by using Qiskit Runtime Primitives.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"A primitive is a small building block that you can use to design a larger circuit or job. The two primitives that are most important to us are the sampler and the estimator, which we'll discuss in more depth shortly.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":["With the recent release of Qiskit v1.0, Qiskit has become more performative and stable than ever before. So, for those of you just getting started, you came in at the perfect time! For those of you that are already familiar with Qiskit, you'll need to download and reinstall the newest version. For a full installation guide, visit ",["$","$L19",null,{"href":"/docs/guides/install-qiskit","className":"text-link-primary no-underline hover:underline inline","children":"the Install Qiskit"}]," guide."],"className":"group paragraph-el text-text-primary mx-0"}],"\n",[["$","hr",null,{"className":"mt-48 lg:mt-64 mb-16 md:mb-24 my-16 lg:my-24 border-t border-border-subtle box-content overflow-visible"}],["$","h2",null,{"id":"quantum-circuits","className":"group relative mx-0 scroll-pt-[var(--shell-top-bar-height)] [overflow-wrap:anywhere] text-heading-04 text-text-primary","children":["Quantum Circuits",["$","a",null,{"title":"Permalink to this headline","href":"#quantum-circuits","className":"text-link-primary no-underline hover:underline inline heading-permalink ml-[8px] top-0 opacity-0 group-hover:opacity-100 focus:opacity-100 transition-[opacity] duration-75 ease-[cubic-bezier(0.2,0,0.38,0.9)]","children":["$","svg",null,{"focusable":"false","preserveAspectRatio":"xMidYMid meet","fill":"currentColor","width":16,"height":16,"viewBox":"0 0 32 32","aria-hidden":true,"className":"inline","xmlns":"http://www.w3.org/2000/svg","children":["$15","$17","$undefined"]}]}]]}]],"\n",["$","p",null,{"children":["Now we're ready to discuss the foundation of quantum programs: quantum circuits. This section will only serve as a refresher — if you aren't familiar with quantum circuits, we recommend learning about them in more depth by visiting the ",["$","$L19",null,{"href":"/learning/courses/basics-of-quantum-information/quantum-circuits/introduction","className":"text-link-primary no-underline hover:underline inline","children":"Quantum Circuits"}]," lesson in the \"Basics of quantum information\" course before continuing."],"className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"A quantum circuit is a network of quantum gates and measurements linked by wires that represent qubits, as shown below. Quantum circuits can be read like sheet music, from left to right, starting at time 0 on the left. Virtual qubits — those that haven't yet been assigned to a physical qubit on a processor — are listed in increasing order from top to bottom.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"Gates are represented by different symbols on the wires of the involved qubit(s). Single-qubit gates — like a Hadamard gate, depicted below (the box with the H) — affect only the qubit whose wire it's placed on. Multi-qubit gates — like a CNOT gate, also shown below (the plus sign in the circle with a line connected to q0) — affect two or more qubits. In the depicted CNOT gate, the state of the q1 changes according to the state of q0. After all the gates are performed, we can measure the qubits, indicated by the black gates with the measurement symbol. The outcomes of the measurements are written onto classical registers, the double-lined “meas” bus below.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","$L1a",null,{"src":"/documentation/pr-3950/learning/images/courses/quantum-computing-in-practice/running-quantum-circuits/simplecircuit.avif","alt":"Example simple quantum circuit","width":"2715","height":"1424"}],"\n",["$","p",null,{"children":"One important characteristic of a circuit is its depth. The depth of a quantum circuit is the minimum number of “layers” of quantum gates, executed in parallel, required to complete the circuit. Quantum gates can be executed in parallel (at the same time) whenever they don't have any qubits in common. But if two or more gates act of the same qubit then we can't perform them in parallel — they must be performed in two separate layers, one after the other.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"There's another, less obvious, way to determine the depth of a circuit, by playing a sort of game. The rules are simple: starting from any qubit wire on the left, you must travel to the right and count the number of gates you encounter in your path. You may hop to a neighboring wire only when it is connected to your current wire by a multi-qubit gate. The goal is to maximize the number of gates you encounter along your path. This maximal number also happens to be the depth of the circuit.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","$L1a",null,{"src":"/documentation/pr-3950/learning/images/courses/quantum-computing-in-practice/running-quantum-circuits/circuitdepth.avif","alt":"Example nine-layer circuit","width":"3840","height":"1893"}],"\n",["$","p",null,{"children":"Because quantum gates take time to implement, the depth of a circuit roughly corresponds to the amount of time needed for a quantum computer to execute the circuit. Some machines are better suited for large depth circuits than others due to the decoherence times of the qubits on the processor. So, we need to know the depth of a circuit to know if it can be run on a particular device.","className":"group paragraph-el text-text-primary mx-0"}],"\n",[["$","hr",null,{"className":"mt-48 lg:mt-64 mb-16 md:mb-24 my-16 lg:my-24 border-t border-border-subtle box-content overflow-visible"}],["$","h2",null,{"id":"designing-a-quantum-circuit-qiskit-patterns","className":"group relative mx-0 scroll-pt-[var(--shell-top-bar-height)] [overflow-wrap:anywhere] text-heading-04 text-text-primary","children":["Designing a quantum circuit: Qiskit patterns",["$","a",null,{"title":"Permalink to this headline","href":"#designing-a-quantum-circuit-qiskit-patterns","className":"text-link-primary no-underline hover:underline inline heading-permalink ml-[8px] top-0 opacity-0 group-hover:opacity-100 focus:opacity-100 transition-[opacity] duration-75 ease-[cubic-bezier(0.2,0,0.38,0.9)]","children":["$","svg",null,{"focusable":"false","preserveAspectRatio":"xMidYMid meet","fill":"currentColor","width":16,"height":16,"viewBox":"0 0 32 32","aria-hidden":true,"className":"inline","xmlns":"http://www.w3.org/2000/svg","children":["$15","$17","$undefined"]}]}]]}]],"\n",["$","p",null,{"children":"So, how do we go about designing and running a quantum circuit? The easiest way to understand a typical quantum computing workflow is through Qiskit patterns. Qiskit patterns are a conceptual framework allowing users to run quantum workloads by implementing certain steps with modular tooling. This allows quantum computing tasks to be performed by a powerful heterogenous (CPU/GPU/QPU) computing infrastructure. The steps can be performed as-a-service and can incorporate resource management, which allows for the seamless composability of new capabilities as they're developed.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"Here are the main steps, which experienced Qiskit users will likely recognize.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Map."}]," This step formalizes how we take a general problem we're interested in and figure out how to map it onto a quantum computer in the form of a quantum circuit."],"className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Optimize."}]," In this step we use Qiskit's transpiler to route and lay out the circuit onto an actual, physical qubit hardware. This includes translating the individual quantum gates into sequences of operations that are performed on the hardware as well as an optimization in the layout of the gates."],"className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Execute."}]," Qiskit Runtime primitives provide the interface to IBM Quantum hardware that allows transpiled circuits to run. This step also includes using error suppression and mitigation techniques, which can largely be abstracted away from the user."],"className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"Post-process."}]," In this step the data from the quantum processor itself is processed, providing the user with useful results on the original problem. Basically, this encompasses any further analysis of the data acquired."],"className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n"],"className":"list-outside ml-32 list-decimal tabular-nums"}],"\n",["$","h3",null,{"id":"map","className":"group relative mx-0 scroll-pt-[var(--shell-top-bar-height)] [overflow-wrap:anywhere] text-heading-03 text-text-primary","children":["Map",["$","a",null,{"title":"Permalink to this headline","href":"#map","className":"text-link-primary no-underline hover:underline inline heading-permalink ml-[8px] top-0 opacity-0 group-hover:opacity-100 focus:opacity-100 transition-[opacity] duration-75 ease-[cubic-bezier(0.2,0,0.38,0.9)]","children":["$","svg",null,{"focusable":"false","preserveAspectRatio":"xMidYMid meet","fill":"currentColor","width":16,"height":16,"viewBox":"0 0 32 32","aria-hidden":true,"className":"inline","xmlns":"http://www.w3.org/2000/svg","children":["$15","$17","$undefined"]}]}]]}],"\n",["$","p",null,{"children":"The Map step essentially asks the question: “How do I translate my problem into a quantum circuit that can reasonably be run on quantum hardware?” There's no doubt about it: mapping is a hard problem and an active area of research. There isn't a foolproof method that guarantees success, but there are recommended guidelines and examples of problems we already know how to map.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"The first guideline is to let classical computers do whatever work they're better at. Tasks that are easy for classical computers probably won't benefit from a quantum computer. Quantum computers are for problems that are classically hard. Of course, if this is your very first time using Qiskit or a quantum computer, don't worry about finding a problem that is computationally complex. Break it down into smaller, bite-sized problems that you can learn to address before going straight for a utility-scale project.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"Next, translate the outcomes for your problem that you want to measure or understand into an expectation value or a cost function. A cost function is a problem-specific function that defines the problem's goal as something to be minimized or maximized. It can be used to see how well a trial state or solution is performing with respect to that goal. This notion can be applied to various applications in chemistry, machine learning, finance, optimization, and so on — it doesn't necessarily matter from what subject you're approaching the problem.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"Also keep in mind that the hardware you're going to be using has a specific topology, as we discussed in the hardware section. Some qubits are connected, and some aren't — you'll need to map your problem to a circuit that respects IBM quantum processors' heavy-hex topology.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"For now, the most important thing to keep in mind is that this stage requires practice. You need to have a good understanding of not only your problem, but also the hardware capabilities — and we'll go through specific examples and use-cases in future lessons to see how to balance all these considerations.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","h3",null,{"id":"optimize","className":"group relative mx-0 scroll-pt-[var(--shell-top-bar-height)] [overflow-wrap:anywhere] text-heading-03 text-text-primary","children":["Optimize",["$","a",null,{"title":"Permalink to this headline","href":"#optimize","className":"text-link-primary no-underline hover:underline inline heading-permalink ml-[8px] top-0 opacity-0 group-hover:opacity-100 focus:opacity-100 transition-[opacity] duration-75 ease-[cubic-bezier(0.2,0,0.38,0.9)]","children":["$","svg",null,{"focusable":"false","preserveAspectRatio":"xMidYMid meet","fill":"currentColor","width":16,"height":16,"viewBox":"0 0 32 32","aria-hidden":true,"className":"inline","xmlns":"http://www.w3.org/2000/svg","children":["$15","$17","$undefined"]}]}]]}],"\n",["$","p",null,{"children":"Next, we'll need to choose a quantum processor that has enough qubits of high enough quality that we can run our quantum circuit. Make these decisions guided by the three metrics that we discussed in the hardware section: qubit count, EPLG, and CLOPS.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"Then we optimize our circuit for the selected hardware. First, we need to lay out and route our circuit efficiently. Layout refers to mapping the virtual qubits in the circuit to the physical qubits on the processor. Routing refers to tweaking the circuit so that the connectivity between virtual qubits in the circuit matches the connectivity of the physical qubits on the processor. There are a couple of things to keep in mind during the layout and routing stage.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"Not all qubits are connected. Some are very far away from one another on the chip, and we need to reduce or eliminate long-distance interactions wherever possible. You could apply a sequence of SWAP gates between neighboring qubits to move the qubits information around, but SWAP gates are costly and prone to errors, so there may be betters ways of doing this. Try to avoid too many costly SWAP gates.","className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":["Layout and routing are iterative processes. You can do it by hand, but there's also a Qiskit tool called ",["$","code",null,{"children":"mapomatic","className":"text-code-02 inline px-4 bg-background border border-transparent dark:border-border-subtle-00 [overflow-wrap:anywhere] group-[.pre-el]:text-code-02 group-[.pre-el]:inline-block group-[.pre-el]:whitespace-pre group-[.pre-el]:p-12 group-[.pre-el]:pr-[50px] group-[.pre-el]:bg-inherit dark:group-[.pre-el]:border-transparent group-[.paragraph-el]:whitespace-normal"}],", which can make recommendations for a physical qubit layout based on approximate error rates. The transpiler (which we'll discuss shortly) can also make an informed suggestion."],"className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n"],"className":"list-outside ml-32 list-decimal tabular-nums"}],"\n",["$","p",null,{"children":"Next, we can compose sequences of one-qubit gates acting on the same qubit into single gates — and we can also sometimes get rid of unnecessary gates or combination of gates. For example, some combinations of gates can be reduced to simpler combinations — and in fact, sometimes a combination of gates might equate to the identity operation, so we can simply eliminate them. You can do this automatically using the Qiskit transpiler — but you can also do it manually on a gate-by-gate basis if you want more control.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"Once we've improved the circuit layout, routing and gate counts — either by hand or using the transpiler — we usually want to visualize our circuit to make sure the timing of all the gates makes sense. There is an argument you can flag in the transpiler to visualize the timeline of your circuit, and make sure everything is lined up the way you would expect.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","h4",null,{"id":"qiskit-transpiler","className":"group relative mx-0 scroll-pt-[var(--shell-top-bar-height)] [overflow-wrap:anywhere] text-heading-compact-02 text-text-primary","children":["Qiskit Transpiler",["$","a",null,{"title":"Permalink to this headline","href":"#qiskit-transpiler","className":"text-link-primary no-underline hover:underline inline heading-permalink ml-[8px] top-0 opacity-0 group-hover:opacity-100 focus:opacity-100 transition-[opacity] duration-75 ease-[cubic-bezier(0.2,0,0.38,0.9)]","children":["$","svg",null,{"focusable":"false","preserveAspectRatio":"xMidYMid meet","fill":"currentColor","width":16,"height":16,"viewBox":"0 0 32 32","aria-hidden":true,"className":"inline","xmlns":"http://www.w3.org/2000/svg","children":["$15","$17","$undefined"]}]}]]}],"\n",["$","p",null,{"children":"As mentioned previously, the Qiskit Transpiler can be used to help in the early stages of the patterns workflow. Now let's dig into its capabilities in more detail. It can rewrite a given input circuit so that it matches the topology of a specific quantum device and optimize the circuit for execution and resilience against noise. It also rewrites a given circuit into basis gates of the specific quantum processor you have selected to use.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"Qiskit has four built-in transpilation pipelines corresponding to different optimization levels, and unless you're already familiar with quantum circuit optimization, we recommend using one of them. By default, the transpilation process includes these six steps:","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"Initialization. This stage runs any initial passes that are required before we start embedding the circuit onto the backend. This typically involves unrolling custom instructions and converting the circuit to just single- and two-qubit gates.","className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":["Layout. This stage maps the virtual qubits in the circuit to the physical qubits on a backend. See ",["$","$L19",null,{"href":"/docs/api/qiskit/transpiler#layout-stage","className":"text-link-primary no-underline hover:underline inline","children":"Layout Stage"}]," for more details."],"className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":["Routing. This stage runs after a layout has been applied and injects gates (such as swap gates) into the original circuit to make it compatible with the backend's connectivity. See ",["$","$L19",null,{"href":"/docs/api/qiskit/transpiler#routing-stage","className":"text-link-primary no-underline hover:underline inline","children":"Routing Stage"}]," for more details."],"className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":["Translation. This stage translates the gates in the circuit to the target backend's basis set. See ",["$","$L19",null,{"href":"/docs/api/qiskit/transpiler#translation-stage","className":"text-link-primary no-underline hover:underline inline","children":"Translation Stage"}]," for more details."],"className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"Optimization. This stage runs the main optimization loop repeatedly until a condition (such as reaching a certain target depth) is reached. We have four different optimization levels to choose from, described below.","className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"Scheduling. This stage is for any hardware-aware scheduling passes.  At a high level, the scheduling can be thought of as inserting delays into the circuit to account for idle time on the qubits between the execution of instructions.","className":"group paragraph-el text-text-primary mx-0"}],"\n"],"className":"my-12"}],"\n"],"className":"list-outside ml-32 list-decimal tabular-nums"}],"\n",["$","p",null,{"children":["There are four optimization levels ranging from 0 to 3, where higher optimization levels take more time and computational effort but may yield a better circuit. Optimization level 0 is intended for device characterization experiments and, as such, only maps the input circuit to the constraints of the target backend, without performing any optimizations. Optimization level 3 spends the most effort to optimize the circuit. However, as many of the optimization techniques in the transpiler are based on heuristics, spending more computational effort doesn't always result in an improvement in the quality of the output circuit. If this is of further interest, see the ",["$","$L19",null,{"href":"/docs/api/qiskit/transpiler","className":"text-link-primary no-underline hover:underline inline","children":"transpiler documentation"}]," in the Qiskit documentation."],"className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","h4",null,{"id":"error-suppression","className":"group relative mx-0 scroll-pt-[var(--shell-top-bar-height)] [overflow-wrap:anywhere] text-heading-compact-02 text-text-primary","children":["Error suppression",["$","a",null,{"title":"Permalink to this headline","href":"#error-suppression","className":"text-link-primary no-underline hover:underline inline heading-permalink ml-[8px] top-0 opacity-0 group-hover:opacity-100 focus:opacity-100 transition-[opacity] duration-75 ease-[cubic-bezier(0.2,0,0.38,0.9)]","children":["$","svg",null,{"focusable":"false","preserveAspectRatio":"xMidYMid meet","fill":"currentColor","width":16,"height":16,"viewBox":"0 0 32 32","aria-hidden":true,"className":"inline","xmlns":"http://www.w3.org/2000/svg","children":["$15","$17","$undefined"]}]}]]}],"\n",["$","p",null,{"children":"The first step in reducing errors in a circuit is optimizing the layout, routing, and minimizing the gate count, which we've already done, either using the transpiler or on our own. Now let's talk about some more sophisticated methods of error suppression.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"Error suppression refers to a class of techniques that transform a circuit during compilation to minimize errors. It is distinct from error mitigation, which we'll discuss later in the “Execute” section below. The two most common forms of error suppression that we use are dynamical decoupling and Pauli twirling:","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"Dynamical decoupling is used to effectively cancel out some of the environmental noise introduced when a qubit sits idle. By applying a series of gates at specific times, you can make it so the noise that accumulates in one part of the idle period approximately cancels the noise in the other part.","className":"my-12"}],"\n",["$","li",null,{"children":"Pauli twirling is a way of inserting random gates not to cancel the noise, as in dynamical decoupling, but to simplify the noise. By inserting random gates, it prevents the effects of different errors from building up as fast, and makes the noise easier to characterize, since it now has a stochastic nature. This method also forms the basis of a powerful error mitigation technique, which we'll discuss below.","className":"my-12"}],"\n"],"className":"list-outside ml-32 list-decimal tabular-nums"}],"\n",["$","h3",null,{"id":"execute","className":"group relative mx-0 scroll-pt-[var(--shell-top-bar-height)] [overflow-wrap:anywhere] text-heading-03 text-text-primary","children":["Execute",["$","a",null,{"title":"Permalink to this headline","href":"#execute","className":"text-link-primary no-underline hover:underline inline heading-permalink ml-[8px] top-0 opacity-0 group-hover:opacity-100 focus:opacity-100 transition-[opacity] duration-75 ease-[cubic-bezier(0.2,0,0.38,0.9)]","children":["$","svg",null,{"focusable":"false","preserveAspectRatio":"xMidYMid meet","fill":"currentColor","width":16,"height":16,"viewBox":"0 0 32 32","aria-hidden":true,"className":"inline","xmlns":"http://www.w3.org/2000/svg","children":["$15","$17","$undefined"]}]}]]}],"\n",["$","p",null,{"children":"Now we're ready to execute the quantum program. The Qiskit Runtime primitives provide an interface to IBM Quantum hardware, and they also abstract error suppression and mitigation away from the user. There are two primitives to choose from: the Sampler and the Estimator.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":[["$","$L19",null,{"href":"/docs/api/qiskit-ibm-runtime/sampler","className":"text-link-primary no-underline hover:underline inline","children":"Qiskit Runtime's Sampler"}]," runs the circuit multiple times on a quantum device, performing measurements on each run, and reconstructing the probability distribution from the recovered bit strings. The more runs (or shots) it performs, the more accurate the results will be, but this requires more time and quantum resources. Specifically, it calculates the probability of obtaining each possible standard basis state by measuring the state prepared by the circuit."],"className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":[["$","$L19",null,{"href":"/docs/api/qiskit-ibm-runtime/estimator","className":"text-link-primary no-underline hover:underline inline","children":"Qiskit Runtime's Estimator"}]," uses a complex algebraic process to estimate the expectation value on a real quantum device by breaking down the observable into a combination of other observables with known eigenbases."],"className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":["The Execute step is also when we can select ",["$","em",null,{"children":"error mitigation"}]," strategy. ",["$","em",null,{"children":"Error mitigation"}]," refers to techniques that allow users to reduce circuit errors by modeling the device noise that was present at the time of execution. Typically, this results in quantum pre-processing overhead related to model training and classical post-processing overhead to mitigate errors in the raw results by using the generated model. In exchange for this overhead, we're able to get much more accurate results."],"className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"There are multiple techniques we can implement for error mitigation. We'll discuss three, in increasing order of resilience to errors, but also, consequently, in increasing order of computational cost. Be aware, however, that this is an active area of research — so we'll likely continue to invent new ones and improve upon old ones.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"At resilience level 0, the transpiler doesn't do anything to your circuit.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"At level 1, it introduces a method called Twirled Readout Error eXtinction (T-REX). T-REX uses Pauli twirling, as was discussed in the error suppression section. As mentioned, inserting random gates into the circuit can make even very complicated, difficult-to-model noise look stochastic, and much easier to account for or subtract out in post-processing.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"At resilience level 2, Zero Noise Extrapolation (ZNE) is added. This is a popular technique that we've had a lot of recent success with. The idea behind ZNE might be a bit surprising — we actually add noise on top of what's already there! But this allows us to extrapolate in the reverse direction, to predict what the results would look like if there were less and less noise.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"Adding noise can be accomplished in a few different ways. For instance, we can stretch out the gates to make them longer and thus, more prone to error, or run more gates that ultimately result in an identity operation, so the circuit doesn't change functionally but we purposefully sample more noise. You do have to do this for every circuit and every expectation value you want to keep track of, though — so you can see how it can end up being computationally expensive.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"One specific type of ZNE is called Probabilistic Error Amplification (PEA). Once we've learned a noise model for a gate, PEA works by sampling errors from that noise model and deliberately injecting them into the circuit. This isn't available in Qiskit yet, but it will be later this year.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"The final form of error mitigation we'll discuss is Probabilistic Error Cancellation (PEC). Instead of being at the 3rd resilience level, PEC is a special capability you must turn on manually in Qiskit, because the required computational resources don't scale very well compared to the other error mitigation techniques. You begin by learning about the noise that's affecting your circuit — run noise-learning or noise-characterization circuits for each unique layer of two-qubit gates in your circuit. These results let you describe the noise in terms of Pauli operators. Once you know these noise terms, you can modify your circuits so that they effectively have the opposite Pauli gates built in to cancel these noise channels. In some ways, the process is similar to the way noise-cancelling headphones work. However, this way of undoing the noise is very costly, with a time to run that grows quickly and exponentially in the number of gates, so it may not be the best choice for a very large circuit.","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","h3",null,{"id":"post-process","className":"group relative mx-0 scroll-pt-[var(--shell-top-bar-height)] [overflow-wrap:anywhere] text-heading-03 text-text-primary","children":["Post-process",["$","a",null,{"title":"Permalink to this headline","href":"#post-process","className":"text-link-primary no-underline hover:underline inline heading-permalink ml-[8px] top-0 opacity-0 group-hover:opacity-100 focus:opacity-100 transition-[opacity] duration-75 ease-[cubic-bezier(0.2,0,0.38,0.9)]","children":["$","svg",null,{"focusable":"false","preserveAspectRatio":"xMidYMid meet","fill":"currentColor","width":16,"height":16,"viewBox":"0 0 32 32","aria-hidden":true,"className":"inline","xmlns":"http://www.w3.org/2000/svg","children":["$15","$17","$undefined"]}]}]]}],"\n",["$","p",null,{"children":"The post-process stage is where we visualize and analyze the output of our quantum circuit. There are a number of Qiskit tools available for you to do this, such as the visualization and quantum-info modules. We won't cover these here, but we'll see these modules in action as we dive into some application examples in future lessons.","className":"group paragraph-el text-text-primary mx-0"}],"\n",[["$","hr",null,{"className":"mt-48 lg:mt-64 mb-16 md:mb-24 my-16 lg:my-24 border-t border-border-subtle box-content overflow-visible"}],["$","h2",null,{"id":"conclusion","className":"group relative mx-0 scroll-pt-[var(--shell-top-bar-height)] [overflow-wrap:anywhere] text-heading-04 text-text-primary","children":["Conclusion",["$","a",null,{"title":"Permalink to this headline","href":"#conclusion","className":"text-link-primary no-underline hover:underline inline heading-permalink ml-[8px] top-0 opacity-0 group-hover:opacity-100 focus:opacity-100 transition-[opacity] duration-75 ease-[cubic-bezier(0.2,0,0.38,0.9)]","children":["$","svg",null,{"focusable":"false","preserveAspectRatio":"xMidYMid meet","fill":"currentColor","width":16,"height":16,"viewBox":"0 0 32 32","aria-hidden":true,"className":"inline","xmlns":"http://www.w3.org/2000/svg","children":["$15","$17","$undefined"]}]}]]}]],"\n",["$","p",null,{"children":"Hopefully this lesson gave you a whirlwind tour of the main considerations and workflow we use when we want to run a utility-scale quantum computation. It was packed with information, and much of it won't sink in until we see some actual examples where these theoretical concepts are put into practice. So, that's what the remainder of the course will be. After all, this course isn't called Quantum Computing in Practice for nothing!","className":"group paragraph-el text-text-primary mx-0"}],"\n",["$","p",null,{"children":"Next time, we'll look at a specific example of how to use the Qiskit patterns workflow to design and run a quantum circuit that solves the classic problem from graph theory called MaxCut.","className":"group paragraph-el text-text-primary mx-0"}]],["$","$L1b",null,{"endpointsPrefix":"","resourceType":"course"}]]}]}]]}],["$","aside",null,{"data-testid":"page-toc","aria-label":"Page navigation and feedback","className":"hidden lg:flex flex-col gap-40 w-[var(--right-toc-menu-width)] mr-[var(--right-toc-margin-right)] sticky top-[var(--app-header-height)] self-start py-24","style":{"marginTop":"40px","maxHeight":"calc(100vh - var(--app-header-height) - 40px)"},"children":["$","$L1c",null,{"headings":[{"depth":1,"value":"Running quantum circuits","compiledValue":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    div: \"div\"\n  }, props.components);\n  return _jsx(_components.div, {\n    children: \"Running quantum circuits\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","id":"running-quantum-circuits"},{"depth":2,"value":"Lesson overview","compiledValue":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    div: \"div\"\n  }, props.components);\n  return _jsx(_components.div, {\n    children: \"Lesson overview\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","id":"lesson-overview"},{"depth":2,"value":"Hardware – IBM quantum processors","compiledValue":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    div: \"div\"\n  }, props.components);\n  return _jsx(_components.div, {\n    children: \"Hardware – IBM quantum processors\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","id":"hardware--ibm-quantum-processors"},{"depth":2,"value":"Software: Qiskit and Qiskit Runtime","compiledValue":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    div: \"div\"\n  }, props.components);\n  return _jsx(_components.div, {\n    children: \"Software: Qiskit and Qiskit Runtime\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","id":"software-qiskit-and-qiskit-runtime"},{"depth":2,"value":"Quantum Circuits","compiledValue":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    div: \"div\"\n  }, props.components);\n  return _jsx(_components.div, {\n    children: \"Quantum Circuits\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","id":"quantum-circuits"},{"depth":2,"value":"Designing a quantum circuit: Qiskit patterns","compiledValue":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    div: \"div\"\n  }, props.components);\n  return _jsx(_components.div, {\n    children: \"Designing a quantum circuit: Qiskit patterns\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","id":"designing-a-quantum-circuit-qiskit-patterns"},{"depth":3,"value":"Map","compiledValue":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    div: \"div\"\n  }, props.components);\n  return _jsx(_components.div, {\n    children: \"Map\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","id":"map"},{"depth":3,"value":"Optimize","compiledValue":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    div: \"div\"\n  }, props.components);\n  return _jsx(_components.div, {\n    children: \"Optimize\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","id":"optimize"},{"depth":4,"value":"Qiskit Transpiler","compiledValue":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    div: \"div\"\n  }, props.components);\n  return _jsx(_components.div, {\n    children: \"Qiskit Transpiler\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","id":"qiskit-transpiler"},{"depth":4,"value":"Error suppression","compiledValue":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    div: \"div\"\n  }, props.components);\n  return _jsx(_components.div, {\n    children: \"Error suppression\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","id":"error-suppression"},{"depth":3,"value":"Execute","compiledValue":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    div: \"div\"\n  }, props.components);\n  return _jsx(_components.div, {\n    children: \"Execute\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","id":"execute"},{"depth":3,"value":"Post-process","compiledValue":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    div: \"div\"\n  }, props.components);\n  return _jsx(_components.div, {\n    children: \"Post-process\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","id":"post-process"},{"depth":2,"value":"Conclusion","compiledValue":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    div: \"div\"\n  }, props.components);\n  return _jsx(_components.div, {\n    children: \"Conclusion\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","id":"conclusion"}],"minHeadingLevel":2,"maxHeadingLevel":3}]}]]}]
14:["$","iframe",null,{"className":"w-full h-[405px]","src":"https://video.ibm.com/embed/recorded/134063416?showtitle=false","allowFullScreen":true,"title":"In this video, Olivia Lanes explains quantum circuits and primitives. She covers Qiskit Runtime primitives estimator and sampler.","referrerPolicy":"no-referrer-when-downgrade","sandbox":"allow-scripts allow-same-origin"}]
